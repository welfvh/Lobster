#!/bin/bash
#===============================================================================
# Pre-Push Hook: PII & Security Scanner with Auto-Fix
#
# Scans files being pushed for:
#   - PII (emails, phone numbers, SSNs, credit cards, IP addresses)
#   - Security issues (API keys, tokens, credentials, private keys)
#
# Auto-fixes where possible, blocks push for unfixable issues.
#
# Allowlist: .githooks/security-allowlist.txt
#===============================================================================

set -uo pipefail

# Colors (only when terminal is available)
if [ -t 1 ]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    CYAN='\033[0;36m'
    BOLD='\033[1m'
    NC='\033[0m'
else
    RED='' GREEN='' YELLOW='' CYAN='' BOLD='' NC=''
fi

REPO_ROOT="$(git rev-parse --show-toplevel)"
ALLOWLIST_FILE="$REPO_ROOT/.githooks/security-allowlist.txt"
ISSUES_FOUND=0
ISSUES_FIXED=0
UNFIXABLE_ISSUES=0

#===============================================================================
# Helpers
#===============================================================================

info()  { echo -e "${CYAN}[SCAN]${NC} $1"; }
warn()  { echo -e "${YELLOW}[WARN]${NC} $1"; }
fix()   { echo -e "${GREEN}[FIX]${NC}  $1"; }
block() { echo -e "${RED}[BLOCK]${NC} $1"; }

# Check if a file:pattern combo is in the allowlist
is_allowlisted() {
    local filepath="$1"
    local pattern_desc="$2"

    if [ ! -f "$ALLOWLIST_FILE" ]; then
        return 1
    fi

    # Strip leading ./ from filepath for matching
    filepath="${filepath#./}"

    while IFS= read -r line; do
        # Skip comments and blank lines
        [[ "$line" =~ ^#.*$ || -z "$line" ]] && continue

        local allowed_file="${line%%:*}"
        local allowed_pattern="${line#*:}"

        # Check if filepath matches (supports glob-style prefix matching)
        if [[ "$filepath" == $allowed_file ]] && [[ "$pattern_desc" == *"$allowed_pattern"* ]]; then
            return 0
        fi
    done < "$ALLOWLIST_FILE"

    return 1
}

# Get the list of files being pushed (comparing local ref to remote ref)
get_pushed_files() {
    local remote="$1"
    local url="$2"
    local files=""

    while read -r local_ref local_sha remote_ref remote_sha; do
        if [ "$local_sha" = "0000000000000000000000000000000000000000" ]; then
            # Deleting a branch, nothing to scan
            continue
        fi

        if [ "$remote_sha" = "0000000000000000000000000000000000000000" ]; then
            # New branch - scan all commits against the default branch
            local default_branch
            default_branch="$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || echo 'main')"
            local merge_base
            merge_base="$(git merge-base "$default_branch" "$local_sha" 2>/dev/null || echo "")"
            if [ -n "$merge_base" ]; then
                files="$files$(git diff --name-only --diff-filter=ACMRT "$merge_base" "$local_sha" 2>/dev/null || true)"
            else
                # Fallback: scan all files in the commit
                files="$files$(git diff-tree --no-commit-id --name-only -r "$local_sha" 2>/dev/null || true)"
            fi
        else
            # Existing branch update - scan only new commits
            files="$files$(git diff --name-only --diff-filter=ACMRT "$remote_sha" "$local_sha" 2>/dev/null || true)"
        fi
    done

    # Deduplicate and filter to existing files
    echo "$files" | sort -u | while read -r f; do
        [ -n "$f" ] && [ -f "$REPO_ROOT/$f" ] && echo "$f"
    done
}

#===============================================================================
# Pattern Definitions
#
# Format: name@@regex@@description@@fixable(yes/no)@@replacement
# Using @@ as delimiter to avoid conflicts with regex pipe characters.
#===============================================================================

PII_PATTERNS=(
    'email@@[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}@@Email address@@yes@@<REDACTED_EMAIL>'
    'phone@@(\+?1[-.\s]?)?\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}@@Phone number@@yes@@<REDACTED_PHONE>'
    'ssn@@\b\d{3}-\d{2}-\d{4}\b@@Social Security Number@@yes@@<REDACTED_SSN>'
    'cc@@\b(?:4\d{3}|5[1-5]\d{2}|3[47]\d{2}|6(?:011|5\d{2}))[- ]?\d{4}[- ]?\d{4}[- ]?\d{4}\b@@Credit card number@@yes@@<REDACTED_CC>'
    'ip@@\b(?!127\.0\.0\.1\b)(?!0\.0\.0\.0\b)\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b@@IP address@@no@@'
)

SECURITY_PATTERNS=(
    'api_key_sk@@sk-[a-zA-Z0-9_-]{20,}@@API secret key (sk-...)@@yes@@<REDACTED_API_KEY>'
    'api_key_pk@@pk_(?:live|test)_[a-zA-Z0-9]{20,}@@Publishable key (pk_...)@@yes@@<REDACTED_PUB_KEY>'
    'aws_key@@AKIA[0-9A-Z]{16}@@AWS Access Key ID@@yes@@<REDACTED_AWS_KEY>'
    'aws_secret@@(?<![A-Za-z0-9/+=])[A-Za-z0-9/+=]{40}(?![A-Za-z0-9/+=])@@Possible AWS Secret Key (40-char)@@no@@'
    "password@@(?i)((?:password|passwd|pwd)\\s*[=:]\\s*)[\"'][^\"']{4,}[\"']@@Hardcoded password@@yes@@\${1}\"<REDACTED_PASSWORD>\""
    "token_assign@@(?i)((?:token|secret|api_key|apikey|auth_token)\\s*[=:]\\s*)[\"'][^\"']{8,}[\"']@@Hardcoded token/secret@@yes@@\${1}\"<REDACTED_SECRET>\""
    'jwt@@eyJ[a-zA-Z0-9_-]{10,}\.[a-zA-Z0-9_-]{10,}\.[a-zA-Z0-9_-]{10,}@@JWT token@@yes@@<REDACTED_JWT>'
    'private_key@@-----BEGIN (?:RSA |EC |DSA |OPENSSH )?PRIVATE KEY-----@@Private key@@no@@'
    'gcp_key@@"type"\s*:\s*"service_account"@@GCP service account key@@no@@'
    'azure_conn@@(?i)(?:AccountKey|SharedAccessKey)\s*=\s*[A-Za-z0-9+/=]{20,}@@Azure connection string@@yes@@<REDACTED_AZURE_KEY>'
    'github_token@@gh[pousr]_[A-Za-z0-9_]{36,}@@GitHub token@@yes@@<REDACTED_GITHUB_TOKEN>'
    'telegram_token@@\b\d{8,10}:[A-Za-z0-9_-]{35}\b@@Telegram bot token@@yes@@<REDACTED_TELEGRAM_TOKEN>'
)

# Files that should never be committed
BLOCKED_FILES=(
    '.env'
    '.env.local'
    '.env.production'
    '.env.staging'
    'id_rsa'
    'id_ed25519'
    'id_ecdsa'
    '*.pem'
    '*.key'
    'credentials.json'
    'service-account*.json'
)

# File extensions to skip (binary, media, etc.)
SKIP_EXTENSIONS='png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot|mp3|mp4|zip|tar|gz|bz2|xz|pdf|pyc|whl|egg|so|dylib|dll'

# Known false-positive email patterns to ignore
EMAIL_ALLOWLIST='noreply@anthropic\.com|noreply@github\.com|example\.com|example\.org|test\.com|localhost'

#===============================================================================
# Scanning Logic
#===============================================================================

scan_file() {
    local filepath="$1"
    local full_path="$REPO_ROOT/$filepath"
    local basename
    basename="$(basename "$filepath")"
    local ext="${basename##*.}"

    # Skip binary / media files
    if [[ "$ext" =~ ^($SKIP_EXTENSIONS)$ ]]; then
        return 0
    fi

    # Skip the allowlist file itself and this hook
    if [[ "$filepath" == ".githooks/security-allowlist.txt" || "$filepath" == ".githooks/pre-push" ]]; then
        return 0
    fi

    # Check blocked filenames
    for blocked in "${BLOCKED_FILES[@]}"; do
        if [[ "$basename" == $blocked ]]; then
            if is_allowlisted "$filepath" "blocked_file"; then
                continue
            fi
            block "$filepath -> Blocked file pattern: $blocked"
            UNFIXABLE_ISSUES=$((UNFIXABLE_ISSUES + 1))
            ISSUES_FOUND=$((ISSUES_FOUND + 1))
            return 0
        fi
    done

    local file_content
    file_content="$(cat "$full_path" 2>/dev/null || true)"
    if [ -z "$file_content" ]; then
        return 0
    fi

    # Scan PII patterns
    for pattern_def in "${PII_PATTERNS[@]}"; do
        local name regex desc fixable replacement
        IFS= read -r name <<< "$(echo "$pattern_def" | awk -F'@@' '{print $1}')"
        IFS= read -r regex <<< "$(echo "$pattern_def" | awk -F'@@' '{print $2}')"
        IFS= read -r desc <<< "$(echo "$pattern_def" | awk -F'@@' '{print $3}')"
        IFS= read -r fixable <<< "$(echo "$pattern_def" | awk -F'@@' '{print $4}')"
        IFS= read -r replacement <<< "$(echo "$pattern_def" | awk -F'@@' '{print $5}')"

        local matches
        matches="$(echo "$file_content" | grep -Pn -e "$regex" 2>/dev/null || true)"

        if [ -z "$matches" ]; then
            continue
        fi

        # For emails, filter out known false positives
        if [ "$name" = "email" ]; then
            matches="$(echo "$matches" | grep -Pv "$EMAIL_ALLOWLIST" || true)"
            if [ -z "$matches" ]; then
                continue
            fi
        fi

        # For phone numbers, only flag if in non-code context (reduce false positives)
        if [ "$name" = "phone" ]; then
            if [[ "$ext" =~ ^(py|js|ts|go|rs|c|h|cpp|java)$ ]]; then
                # Only flag if it looks like assigned to a phone-related variable
                matches="$(echo "$matches" | grep -Pi '(?:phone|mobile|cell|tel|fax|contact)' || true)"
                if [ -z "$matches" ]; then
                    continue
                fi
            fi
        fi

        # For IP addresses, skip common non-sensitive patterns (private ranges)
        if [ "$name" = "ip" ]; then
            matches="$(echo "$matches" | grep -Pv '(?:255\.255\.255\.\d+|192\.168\.\d+\.\d+|10\.\d+\.\d+\.\d+|172\.(?:1[6-9]|2\d|3[01])\.\d+\.\d+)' || true)"
            if [ -z "$matches" ]; then
                continue
            fi
        fi

        if is_allowlisted "$filepath" "$desc"; then
            continue
        fi

        ISSUES_FOUND=$((ISSUES_FOUND + 1))

        if [ "$fixable" = "yes" ] && [ -n "$replacement" ]; then
            # Auto-fix: replace pattern matches in the file using perl (portable PCRE)
            perl -pi -e "s/$regex/$replacement/g" "$full_path" 2>/dev/null || true
            fix "$filepath -> $desc replaced with $replacement"
            ISSUES_FIXED=$((ISSUES_FIXED + 1))
            # Re-stage the fixed file
            git add "$full_path" 2>/dev/null || true
        else
            warn "$filepath -> $desc (manual review needed)"
            echo "$matches" | head -3 | while read -r line; do
                echo "       Line: $line"
            done
            UNFIXABLE_ISSUES=$((UNFIXABLE_ISSUES + 1))
        fi
    done

    # Re-read file content in case PII fixes changed it
    file_content="$(cat "$full_path" 2>/dev/null || true)"
    if [ -z "$file_content" ]; then
        return 0
    fi

    # Scan security patterns
    for pattern_def in "${SECURITY_PATTERNS[@]}"; do
        local name regex desc fixable replacement
        IFS= read -r name <<< "$(echo "$pattern_def" | awk -F'@@' '{print $1}')"
        IFS= read -r regex <<< "$(echo "$pattern_def" | awk -F'@@' '{print $2}')"
        IFS= read -r desc <<< "$(echo "$pattern_def" | awk -F'@@' '{print $3}')"
        IFS= read -r fixable <<< "$(echo "$pattern_def" | awk -F'@@' '{print $4}')"
        IFS= read -r replacement <<< "$(echo "$pattern_def" | awk -F'@@' '{print $5}')"

        local matches
        matches="$(echo "$file_content" | grep -Pn -e "$regex" 2>/dev/null || true)"

        if [ -z "$matches" ]; then
            continue
        fi

        # For password/token patterns, skip lines where value is a variable reference
        if [ "$name" = "password" ] || [ "$name" = "token_assign" ]; then
            matches="$(echo "$matches" | grep -Pv '[=:]\s*["'"'"']\$' || true)"
            if [ -z "$matches" ]; then
                continue
            fi
        fi

        # For aws_secret, too many false positives - only flag in config-like files
        if [ "$name" = "aws_secret" ]; then
            if [[ ! "$ext" =~ ^(env|cfg|conf|ini|yml|yaml|json|toml)$ ]] && [[ ! "$basename" =~ ^(config|settings|credentials) ]]; then
                continue
            fi
        fi

        if is_allowlisted "$filepath" "$desc"; then
            continue
        fi

        ISSUES_FOUND=$((ISSUES_FOUND + 1))

        if [ "$fixable" = "yes" ] && [ -n "$replacement" ]; then
            perl -pi -e "s/$regex/$replacement/g" "$full_path" 2>/dev/null || true
            fix "$filepath -> $desc replaced with $replacement"
            ISSUES_FIXED=$((ISSUES_FIXED + 1))
            git add "$full_path" 2>/dev/null || true
            # Re-read file content after fix
            file_content="$(cat "$full_path" 2>/dev/null || true)"
        else
            block "$filepath -> $desc (cannot auto-fix)"
            echo "$matches" | head -3 | while read -r line; do
                echo "       Line: $line"
            done
            UNFIXABLE_ISSUES=$((UNFIXABLE_ISSUES + 1))
        fi
    done
}

#===============================================================================
# Main
#===============================================================================

echo ""
echo -e "${BOLD}Pre-Push Security & PII Scanner${NC}"
echo "================================"

# Get files being pushed from stdin
FILES="$(get_pushed_files "$@")"

if [ -z "$FILES" ]; then
    info "No files to scan."
    echo ""
    exit 0
fi

FILE_COUNT="$(echo "$FILES" | wc -l)"
info "Scanning $FILE_COUNT file(s)..."

while IFS= read -r file; do
    [ -n "$file" ] && scan_file "$file"
done <<< "$FILES"

echo ""
echo "================================"

if [ "$ISSUES_FOUND" -eq 0 ]; then
    echo -e "${GREEN}${BOLD}All clear!${NC} No PII or security issues detected."
    echo ""
    exit 0
fi

echo -e "Issues found:  ${BOLD}$ISSUES_FOUND${NC}"
echo -e "Auto-fixed:    ${GREEN}${BOLD}$ISSUES_FIXED${NC}"
echo -e "Unfixable:     ${RED}${BOLD}$UNFIXABLE_ISSUES${NC}"
echo ""

if [ "$UNFIXABLE_ISSUES" -gt 0 ]; then
    block "Push blocked. Please fix the issues above manually."
    echo ""
    echo "To bypass this check (use with caution):"
    echo "  git push --no-verify"
    echo ""
    echo "To allowlist a false positive, add to .githooks/security-allowlist.txt:"
    echo "  filepath:pattern_description"
    echo ""
    exit 1
fi

if [ "$ISSUES_FIXED" -gt 0 ]; then
    warn "Files were auto-fixed. The fixed versions have been staged."
    echo "Please review the changes, commit them, and push again:"
    echo "  git diff --cached"
    echo "  git commit -m 'security: redact detected secrets'"
    echo "  git push"
    echo ""
    exit 1
fi

exit 0
